package lib

import (
	"fmt"
	"os"
	"path"
	"sort"
	"strings"
	"unicode"

	"github.com/tealeg/xlsx"
)

var (
	lineNumber           = 4                    // 每个工作表需要读取的行数
	structBegin          = "type %s struct {\n" // 结构体开始
	structValueForServer = "    %s %s	"         // 服务端使用的结构体内容
	structRemarks        = "	 // %s"            // 结构体备注
	structValueEnd       = "\n"                 // 结构体内容结束
	structEnd            = "}\n\n"              // 结构体结束
	header               = "// Code generated by configexport.\n" +
		"package sxls\n\r" // 文件头
	userDefStructXlsName = "struct_自定义数据结构表.xlsx" //  自定义街头的excel名
	userDefStructValue   = "    %s %s  // %s\n"
	saveStructName       = "struct.go" // 保存生成的结构体的文件名
	xlsConfigFormat      = "    %s []*%s	\n"
	typeValueBeginFormat = "var AllValues = map[string]any{\n"
	typeValueValueFormat = "	\"%s\":	new(%s),\n"

	excelCount = 100 // excel表的数量
)

var transToGoTyp = map[string]string{
	"int":   "int32",
	"long":  "int64",
	"float": "float64",
	"byte":  "int8",
}

var xlsBasicTyp = "int,long,string,float,bool,byte"

type Generate struct {
	savePath  string            // 生成文件的保存路径
	data      string            // 生成文件的结构体内容
	typeNames map[string]string // 结构体名字（也是sheet名字）

}

// GenStruct 读取excel
func (g *Generate) GenStruct(readPath, savePath string) error {
	if readPath == "" || savePath == "" {
		return fmt.Errorf("GenStruct readPath or savePath is nil")
	}
	g.savePath = savePath
	g.typeNames = make(map[string]string, excelCount)
	files, err := os.ReadDir(readPath)
	if err != nil {
		return fmt.Errorf("GenStruct ReadDir is err:%v", err)
	}
	for _, file := range files {
		if path.Ext(file.Name()) != ".xlsx" {
			continue
		}
		wb, err := xlsx.OpenFile(readPath + "/" + file.Name())
		if err != nil {
			return fmt.Errorf("GenStruct xlsx.OpenFile is err :%v file name:%s", err, file.Name())
		}
		// 生成用户自定义结构体
		if file.Name() == userDefStructXlsName {
			err = g.genUserDefStruct(wb.Sheets[0])
			if err != nil {
				return err
			}
			continue
		}
		// 遍历工作表
		for _, sheet := range wb.Sheets {
			if hasChineseOrDefault(sheet.Name) {
				continue
			}
			sheetData := make([][]string, 0)
			// 判断表格中内容的行数是否小于需要读取的行数
			if sheet.MaxRow < lineNumber {
				return fmt.Errorf("GenStruct[%v] sheet.MaxRow:%d < lineNumber:%d", file.Name(), sheet.MaxRow, lineNumber)
			}
			// 遍历列
			for i := 0; i < sheet.MaxCol; i++ {
				// 判断某一列的第一行是否为空
				if sheet.Cell(0, i).Value == "" {
					continue
				}
				cellData := make([]string, 0)
				// 遍历行
				for j := 0; j < lineNumber; j++ {
					cellData = append(cellData, sheet.Cell(j, i).Value)
				}
				sheetData = append(sheetData, cellData)
			}
			err := g.splicingData(sheetData, sheet.Name)
			if err != nil {
				return fmt.Errorf("fileName:%v is err:%v", file.Name(), err)
			}
			if name1, ok := g.typeNames[sheet.Name]; ok {
				return fmt.Errorf("sheet name repeat:%s %s", name1, file.Name())

			}
			g.typeNames[sheet.Name] = file.Name()
		}
	}
	if g.data == "" {
		return fmt.Errorf("GenStruct data is nil")
	}
	writeErr := g.writeStructFile()
	if writeErr != nil {
		return writeErr
	}
	return nil
}

func (g *Generate) genUserDefStruct(sheet *xlsx.Sheet) error {
	// 判断首字母是否大写
	if firstRuneToUpper(sheet.Name) != sheet.Name {
		return fmt.Errorf("sheet[%v] 名称首字母必须大写", sheet.Name)
	}

	if hasChineseOrDefault(sheet.Name) {
		return fmt.Errorf("sheet[%v] 名称中有中文", sheet.Name)
	}
	sheetData := make([][]string, 0)
	// 遍历行
	for i := 0; i < sheet.MaxRow; i++ {
		// 判断某一列的第一列是否为空
		if sheet.Cell(i, 0).Value == "" {
			continue
		}
		cellData := make([]string, 0)
		// 遍历列
		for j := 0; j < sheet.MaxCol; j++ {
			// 自定义结构体不能有空内容
			if sheet.Cell(i, j).Value == "" {
				break
			}
			cellData = append(cellData, sheet.Cell(i, j).Value)
		}
		sheetData = append(sheetData, cellData)
	}
	return g.splicingUserDefData(sheetData)
}

func (g *Generate) splicingUserDefData(data [][]string) error {
	for _, valueS := range data {
		structData := fmt.Sprintf(structBegin, firstRuneToUpper(valueS[0]))
		for i := 1; i < len(valueS); i++ {
			infoS := strings.Split(valueS[i], "#")
			if len(infoS) != 3 {
				return fmt.Errorf("自定义结构体格式不正确:%v", infoS)
			}
			structData += fmt.Sprintf(userDefStructValue, infoS[0], transToGolangTye(infoS[1]), infoS[2])
		}
		structData += structEnd
		g.data += structData
	}
	return nil
}

// 拼装struct
func (g *Generate) splicingData(data [][]string, structName string) error {
	structData := fmt.Sprintf(structBegin, structName)
	for _, value := range data {
		if len(value) != lineNumber {
			return fmt.Errorf("splicingData sheetName:%v col's len:%d is err", value, len(value))
		}
		err := g.checkType(value[3], structName)
		if err != nil {
			return err
		}

		//特殊处理id，不校验
		if strings.ToLower(value[1]) == "id" {
			structData += fmt.Sprintf(structValueForServer, firstRuneToUpper(strings.ToLower(value[1])), transToGolangTye(value[3]))
			if value[0] != "" {
				structData += fmt.Sprintf(structRemarks, firstLine(value[0]))
			}
			structData += fmt.Sprintf(structValueEnd)
			continue
		}

		//修改case可以读取不同端的配置
		//S:服务端  A:所有人  C:客户端  D:策划  T:测试
		switch value[2] {
		case "S", "A":
			structData += fmt.Sprintf(structValueForServer, firstRuneToUpper(value[1]), transToGolangTye(value[3]))
			if value[0] != "" {
				structData += fmt.Sprintf(structRemarks, firstLine(value[0]))
			}
			structData += fmt.Sprintf(structValueEnd)
		case "C", "D", "T", "":
			continue
		default:
			return fmt.Errorf("splicingData:%v is not in A,S,C,D,G", value[2])
		}
	}
	structData += structEnd
	g.data += structData
	return nil
}

// 生成全局xls config结构体
func (g *Generate) splicingRawConfig() string {
	structData := fmt.Sprintf(structBegin, "RawConfig")
	structNames := make([]string, 0, len(g.typeNames))
	for name := range g.typeNames {
		structNames = append(structNames, name)
	}
	sort.Slice(structNames, func(i, j int) bool {
		return structNames[i] < structNames[j]
	})
	for _, name := range structNames {
		structData += fmt.Sprintf(xlsConfigFormat, name, name)
	}
	structData += structEnd
	return structData
}

// 生成全局xls config结构体
func (g *Generate) splicingTypeValue() string {
	structData := typeValueBeginFormat
	structNames := make([]string, 0, len(g.typeNames))
	for name := range g.typeNames {
		structNames = append(structNames, name)
	}
	sort.Slice(structNames, func(i, j int) bool {
		return structNames[i] < structNames[j]
	})
	for _, name := range structNames {
		structData += fmt.Sprintf(typeValueValueFormat, name, name)
	}
	structData += structEnd
	return structData
}

// 拼装好的struct写入新的文件
func (g *Generate) writeStructFile() error {
	str := strings.Split(g.savePath, "/")
	if len(str) == 0 {
		return fmt.Errorf("writeNewFile len(str) is 0")
	}
	data := header + g.data + g.splicingRawConfig() + g.splicingTypeValue()
	fw, err := os.OpenFile(g.savePath+"/"+saveStructName, os.O_WRONLY|os.O_CREATE, 0o666)
	if err != nil {
		return fmt.Errorf("writeNewFile OpenFile is err:%v", err)
	}
	defer fw.Close()
	_ = fw.Truncate(0)

	_, err = fw.Write([]byte(data))
	if err != nil {
		return fmt.Errorf("writeNewFile Write is err:%v", err)
	}
	return nil
}

// 检测解析出来的字段类型是否符合要求
func (g *Generate) checkType(dataType, structName string) error {
	//if strings.Index(xlsBasicTyp, dataType) == -1 && !strings.HasPrefix(dataType, "List<") {
	//	return fmt.Errorf("checkType struct:%v dataType:%v is not in provide dataType", structName, dataType)
	//}
	return nil
}

// 字符串首字母转换成大写
func firstRuneToUpper(str string) string {
	if len(str) == 0 {
		return str
	}

	// 特殊处理Id
	if strings.ToLower(str) == "id" {
		return "Id"
	}

	return strings.ToUpper(string(str[0])) + str[1:]
}

// 字符串首字母转换成大写并去掉结尾的空格
func capitalizeFirstLetter(s string) string {
	if len(s) == 0 {
		return s
	}

	// 特殊处理Id
	if strings.ToLower(s) == "id" {
		return "Id"
	}

	// 去掉结尾的空格
	s = strings.TrimSpace(s)
	// 将首个字母转化成大写
	return strings.ToUpper(string(s[0])) + s[1:]
}

// 判断是否存在汉字或者是否为默认的工作表
func hasChineseOrDefault(r string) bool {
	if strings.Index(r, "Sheet") != -1 {
		return true
	}
	for _, v := range []rune(r) {
		if unicode.Is(unicode.Han, v) {
			return true
		}
	}
	return false
}

// float => float64
// List<int> => []int
// List<float> => []float64
// List<Item> => []Item
// C#类型转化成golang类型
func transToGolangTye(str string) string {
	if strings.HasPrefix(str, "List<") {
		str1 := str[5 : len(str)-1]
		if goTyp, ok := transToGoTyp[str1]; ok {
			return "[]" + goTyp
		}
		return "[]" + str1
	} else if goTyp, ok := transToGoTyp[str]; ok {
		return goTyp
	}
	return str
}

func firstLine(s string) string {
	i := strings.Index(s, "\n")
	if i == -1 {
		return s // 没有换行符，整个字符串就是第一行
	}
	return s[:i] // 返回第一行
}
